package matrix_examples

func transpose pure(in m1 matrix) mout matrix {
	if (m1.sizes() != 2) return(m1);
	var mout matrix int32;
	for (ii in 0 to m1.size(0)) {	// size(0) == num columns, size(1) == num rows
		mout[ii][:] = m1[:][ii];
	}
	return(mout);
}


var m1 matrix int32;	// size 0

	m1 = [1, 2, 3, 4];	// size 4
	m1 = [m1 :: m1];	// size 2x4
	m1 = transpose(m1);
	
		
// problema reflection e polimorfismo containers.

// empty !!
interface containable {
}		

class matrix {
public:
	var storage [*] containable;
	var dimensions [*] size_t;

	func sizes() size_t;
	func size(dimension size_t) size_t;
	func v(...) containable;
}

func matrix.sizes() size_t {
	return(dimof(dimensions));
}

func matrix.size(in dimension size_t) size_t {
	return(dimensions[dimension]);
}

func matrix.v(...) containable {
	var position size_t = 0;
	var scaler size_t = 1;
	for (ii in 0 sizes()) {
		var maxidx size_t = size(ii);
		var idx = get_argument(ii);
		if (idx >= max_idx) throw;
		position += idx * scaler;
		scaler *= max_idx;
	}
	return (storage[position]);
}

// in c++
class matrix {
public:
	vector<void*> 	storage;
	vector<size_t>	dimensions;

	size_t sizes();
	size_t size(size_t dimension);
	void *v(...);
}

size_t matrix::sizes() {
	return(dimensions.size());
}

size_t matrix::size(size_t dimension) {
	return(dimensions[dimension]);
}

void *matrix::v(...) {
	size_t position = 0;
	size_t scaler = 1;
	for (ii = 0; ii < sizes(); ++ii) {
		size_t maxidx = size(ii);
		size_t idx = get_argument(ii);
		if (idx >= max_idx) throw;
		position += idx * scaler;
		scaler *= max_idx;
	}
	return (storage[position]);
}

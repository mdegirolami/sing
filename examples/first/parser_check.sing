package Main
requires "fake/path/package1"
requires "fake/path/package2"

public var primo volatile int32;
var secondo int32 = 10;
const fisso string = "bello";
const fisso2 = "brutto";
type ComplexType (a int32, b int32) const weak *matrix[3,2][5][8,]map(string) package1.ImportedType;
type quad package1.very.deep.namespace;

func main() void
{
    var c int32;
    c = primo + secondo + sizeof(c);
    //const a = 3;
    //const b = 10;
}

func myclass.chebello pure(in uno int32 = 5, out due int8, io tre string, ...) bool
{
	const size size_t = 3;
	var mm[3][size] float32 = {{1.0, 2.5, 3}, {3}, {3}};
	
	mm[0][0], mm[0][1] = mm[0][1] + mm[0][2], mm[0][1] - mm[0][2];
	mm[0][0] += 3;
	var pippo float32;
	++pippo;
	pippo++;
	pippo--;
	--pippo;
	fun_to_call(3, pippo);
	while (pippo > 0) {
		--pippo;
	}
	if (pippo > 10) {
		pippo *= 2;
	} else if (pippo > 5) {
		pippo += 3;
	} else {
		pippo = 0;
	}
	for (it in mm[0]) {
		it = pippo;
	}
	for (index, it in mm[1]) {
		it = index;
	}
	for (index in 0 : size-1) {
		if (mm[0][index] == 0) {
			continue;
		}
		mm[0][index] = 0;
	}
	for (index in 0 : size - 1 step 2) {
		if (mm[0][index] == 0) {
			break;
		}
		mm[0][index] = 0;
	}
	{
		var inner string = "is inner !!";
		var a float32;
		myclass.member = 10;
		a = pippo + 10 * (mm[1,1] + package1.extvar) / myclass.member;
		*returning_pointer(a : singlepar) = sizeof(float32) + dimof(mm[0]) + (size_t)pippo + -a;
		var test = pippo^3 * 2 + pippo^2 * 5 > 3 && pippo < 0 || pippo > 100;
		test = test || myclass.thebool && 10 < pippo + mm[0][0] * 5^2;
	}
	return(true);
}

func varargs_func (...) void {
}
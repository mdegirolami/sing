
Package = Main
Required fake/path/package1, named package1
Required fake/path/package2, named package2
Var primo volatile {
    int32 type
}
Var secondo with initer {
    int32 type
     10
}
Const fisso {
    string type
    " "bello"
}
Const fisso2 {
    " "brutto"
}
Type ComplexType {
    Function Type is not pure has not varargs has 2 args {
        Argument is named a {
            int32 type
        }
        Argument is named b {
            int32 type
        }
        Pointer is const is weak {
            Array of 5 dimensions is matrix {
                 3
                 2
                 5
                 8
                Map {
                    string type
                    Map Return Value :
                    TypeName package1.ImportedType
                }
            }
        }
    }
}
Type quad {
    TypeName package1.very.deep.namespace
}
Func main {
    Function Type is not pure has not varargs has 0 args {
        void type
    }
    Block {
        Var c{
            int32 type
        }
        Assignment with 1 assignee {
            Left term #0
             c
            Right term #0
            Binop + Operation {
                Binop + Operation {
                     primo
                    Binop second arg :
                     secondo
                }
                Binop second arg :
                Unop sizeof Operation {
                     c
                }
            }
        }
    }
}
Func myclass.chebello {
    Function Type is pure has varargs has 3 args {
        Argument in has initer is named uno {
            int32 type
             5
        }
        Argument out is named due {
            int8 type
        }
        Argument io is named tre {
            string type
        }
        bool type
    }
    Block {
        Const size {
            size_t type
             3
        }
        Var mm with initer {
            Array of 2 dimensions is not matrix {
                 3
                 size
                float32 type
            }
            Initer {
                Initer {
                     1.0
                     2.5
                     3
                }
                Initer {
                     3
                }
                Initer {
                     3
                }
            }
        }
        Assignment with 2 assignee {
            Left term #0
            Indexing {
                 mm
                Index 0 has lower 
                 0
                Index 1 has lower 
                 0
            }
            Left term #1
            Indexing {
                 mm
                Index 0 has lower 
                 0
                Index 1 has lower 
                 1
            }
            Right term #0
            Binop + Operation {
                Indexing {
                     mm
                    Index 0 has lower 
                     0
                    Index 1 has lower 
                     1
                }
                Binop second arg :
                Indexing {
                     mm
                    Index 0 has lower 
                     0
                    Index 1 has lower 
                     2
                }
            }
            Right term #1
            Binop - Operation {
                Indexing {
                     mm
                    Index 0 has lower 
                     0
                    Index 1 has lower 
                     1
                }
                Binop second arg :
                Indexing {
                     mm
                    Index 0 has lower 
                     0
                    Index 1 has lower 
                     2
                }
            }
        }
        Update with += {
            Left term #0
            Indexing {
                 mm
                Index 0 has lower 
                 0
                Index 1 has lower 
                 0
            }
            Right term #0
             3
        }
        Var pippo{
            float32 type
        }
        ++ Operation {
             pippo
        }
        ++ Operation {
             pippo
        }
        -- Operation {
             pippo
        }
        -- Operation {
             pippo
        }
        Function Call {
             fun_to_call
            Arg 0
            Argument  {
                 3
            }
            Arg 1
            Argument  {
                 pippo
            }
        }
        While {
            Binop > Operation {
                 pippo
                Binop second arg :
                 0
            }
            Block {
                -- Operation {
                     pippo
                }
            }
        }
        If {
            If Clause 0 {
                Binop > Operation {
                     pippo
                    Binop second arg :
                     10
                }
                Block {
                    Update with *= {
                        Left term #0
                         pippo
                        Right term #0
                         2
                    }
                }
            }
            If Clause 1 {
                Binop > Operation {
                     pippo
                    Binop second arg :
                     5
                }
                Block {
                    Update with += {
                        Left term #0
                         pippo
                        Right term #0
                         3
                    }
                }
            }
            Block {
                Assignment with 1 assignee {
                    Left term #0
                     pippo
                    Right term #0
                     0
                }
            }
        }
        For , it {
            For Set Expression {
                Indexing {
                     mm
                    Index 0 has lower 
                     0
                }
            }
            Block {
                Assignment with 1 assignee {
                    Left term #0
                     it
                    Right term #0
                     pippo
                }
            }
        }
        For index, it {
            For Set Expression {
                Indexing {
                     mm
                    Index 0 has lower 
                     1
                }
            }
            Block {
                Assignment with 1 assignee {
                    Left term #0
                     it
                    Right term #0
                     index
                }
            }
        }
        For , index {
            For Low Expression {
                 0
            }
            For High Expression {
                Binop - Operation {
                     size
                    Binop second arg :
                     1
                }
            }
            Block {
                If {
                    If Clause 0 {
                        Binop == Operation {
                            Indexing {
                                 mm
                                Index 0 has lower 
                                 0
                                Index 1 has lower 
                                 index
                            }
                            Binop second arg :
                             0
                        }
                        Block {
                            Statement continue
                        }
                    }
                }
                Assignment with 1 assignee {
                    Left term #0
                    Indexing {
                         mm
                        Index 0 has lower 
                         0
                        Index 1 has lower 
                         index
                    }
                    Right term #0
                     0
                }
            }
        }
        For , index {
            For Low Expression {
                 0
            }
            For High Expression {
                Binop - Operation {
                     size
                    Binop second arg :
                     1
                }
            }
            For Step Expression {
                 2
            }
            Block {
                If {
                    If Clause 0 {
                        Binop == Operation {
                            Indexing {
                                 mm
                                Index 0 has lower 
                                 0
                                Index 1 has lower 
                                 index
                            }
                            Binop second arg :
                             0
                        }
                        Block {
                            Statement break
                        }
                    }
                }
                Assignment with 1 assignee {
                    Left term #0
                    Indexing {
                         mm
                        Index 0 has lower 
                         0
                        Index 1 has lower 
                         index
                    }
                    Right term #0
                     0
                }
            }
        }
        Block {
            Var inner with initer {
                string type
                " "is inner !!"
            }
            Var a{
                float32 type
            }
            Assignment with 1 assignee {
                Left term #0
                Binop . Operation {
                     myclass
                    Binop second arg :
                     member
                }
                Right term #0
                 10
            }
            Assignment with 1 assignee {
                Left term #0
                 a
                Right term #0
                Binop + Operation {
                     pippo
                    Binop second arg :
                    Binop / Operation {
                        Binop * Operation {
                             10
                            Binop second arg :
                            Unop ( Operation {
                                Binop + Operation {
                                    Indexing {
                                         mm
                                        Index 0 has lower 
                                         1
                                        Index 1 has lower 
                                         1
                                    }
                                    Binop second arg :
                                    Binop . Operation {
                                         package1
                                        Binop second arg :
                                         extvar
                                    }
                                }
                            }
                        }
                        Binop second arg :
                        Binop . Operation {
                             myclass
                            Binop second arg :
                             member
                        }
                    }
                }
            }
            Assignment with 1 assignee {
                Left term #0
                Unop * Operation {
                    Function Call {
                         returning_pointer
                        Arg 0
                        Argument singlepar {
                             a
                        }
                    }
                }
                Right term #0
                Binop + Operation {
                    Binop + Operation {
                        Binop + Operation {
                            Unop sizeof Operation {
                                float32 type
                            }
                            Binop second arg :
                            Unop dimof Operation {
                                Indexing {
                                     mm
                                    Index 0 has lower 
                                     0
                                }
                            }
                        }
                        Binop second arg :
                        Unop size_t Operation {
                             pippo
                        }
                    }
                    Binop second arg :
                    Unop - Operation {
                         a
                    }
                }
            }
            Var test with initer {
                Binop || Operation {
                    Binop && Operation {
                        Binop > Operation {
                            Binop + Operation {
                                Binop * Operation {
                                    Binop ^ Operation {
                                         pippo
                                        Binop second arg :
                                         3
                                    }
                                    Binop second arg :
                                     2
                                }
                                Binop second arg :
                                Binop * Operation {
                                    Binop ^ Operation {
                                         pippo
                                        Binop second arg :
                                         2
                                    }
                                    Binop second arg :
                                     5
                                }
                            }
                            Binop second arg :
                             3
                        }
                        Binop second arg :
                        Binop < Operation {
                             pippo
                            Binop second arg :
                             0
                        }
                    }
                    Binop second arg :
                    Binop > Operation {
                         pippo
                        Binop second arg :
                         100
                    }
                }
            }
            Assignment with 1 assignee {
                Left term #0
                 test
                Right term #0
                Binop || Operation {
                     test
                    Binop second arg :
                    Binop && Operation {
                        Binop . Operation {
                             myclass
                            Binop second arg :
                             thebool
                        }
                        Binop second arg :
                        Binop < Operation {
                             10
                            Binop second arg :
                            Binop + Operation {
                                 pippo
                                Binop second arg :
                                Binop * Operation {
                                    Indexing {
                                         mm
                                        Index 0 has lower 
                                         0
                                        Index 1 has lower 
                                         0
                                    }
                                    Binop second arg :
                                    Binop ^ Operation {
                                         5
                                        Binop second arg :
                                         2
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        Return {
            true 
        }
    }
}
Func varargs_func {
    Function Type is not pure has varargs has 0 args {
        void type
    }
    Block {
    }
}
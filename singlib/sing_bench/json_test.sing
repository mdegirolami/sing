requires "json";
requires "sio";
requires "str";

public fn jsonTest() bool
{
    var original string;
    var entries [*]json.JsonEntry;
    var errors [*]json.JsonError;

    // parse
    if (sio.fileReadText("json_test/tst.json", original) != 0) {
        return(false);
    }
    if (!json.parseJson(original, entries, errors)) {
        return(false);
    }

    // list the found entries
    var list string;
    for (record in entries) {
        let record_type = record.entry_type;
        switch (record_type) {
            case json.JsonEntryType.number: list += "number";
            case json.JsonEntryType.string_type: list += "string";
            case json.JsonEntryType.boolean: list += "bool";
            case json.JsonEntryType.null_type: list += "null";
            case json.JsonEntryType.array: list += "array";
            case json.JsonEntryType.object: list += "object";
            case json.JsonEntryType.comment: list += "comment";
        }
        list += " " + string(record.level) + " " + record.property_name + " " + record.string_rep + "\r\n";
    }
    _ = sio.fileWriteText("json_test/list.txt", list);

    // rebuild
    var rebuilt string;
    if (!json.writeJson(entries, rebuilt)) {
        return(false);
    }

    // compare, write down if in error
    var fixed string;
    if (sio.fileReadText("json_test/fixed.json", fixed) != 0) {
        return(false);
    }

    // in case git changes /r/n in /n
    _ = str.replaceAll(rebuilt, "\r\n", "\n");
    _ = str.replaceAll(fixed, "\r\n", "\n");

    if (rebuilt != fixed) {
        _ = sio.fileWriteText("json_test/rebuilt.json", rebuilt);
        return(false);
    }
    return(true);
}

public class Node {
public:    
    var next *Node;
    fn clone() *Node;
    fn clone2() *Node;
}

public fn dupList(list *Node) *Node
{
    if (list == null) {
        return(null);
    } else {
        var dup = *list;
        dup.next = dupList(list.next);
        return(&dup);
    }
}

public fn dupList2(list const*Node) *Node
{
    var scan = list;
    var newlist *Node;
    var last *Node;
    while (scan != null) {
        var dup = *scan;
        if (last != null) {
            last.next = &dup;
        } else {
            newlist = &dup;
        }
        last = &dup;
        scan = scan.next;
    }
    return(newlist);
}

public fn dupList3(list const*Node) *Node
{
    if (list == null) {
        return(null);
    }
    var scan = list;
    var newlist = *list;
    var last = &newlist;
    while (scan != null) {
        var dup = *scan;
        if (last != null) {
            last.next = &dup;
        }
        last = &dup;
        scan = scan.next;
    }
    return(&newlist);
}

fn Node.clone() *Node
{
    var dup Node = this;
    dup.next = dupList(this.next);
    return(&dup);
}


fn Node.clone2() *Node
{
    var newlist = this;
    var scan = this.next;
    var last = &newlist;
    while (scan != null) {
        var dup = *scan;
        last.next = &dup;
        last = &dup;
        scan = scan.next;
    }
    return(&newlist);
}
 



3:11: Auto variables require a single expression initer
8:8: Void only allowed as a function return type
9:8: Undefined type
10:9: Expected a type name
11:13: Void only allowed as a function return type
12:13: Void only allowed as a function return type
13:21: Undefined type
14:10: Undefined type
15:15: Void only allowed as a function return type
16:28: You can apply argument initers only to input parameters
17:14: Only a single value is allowed here(not an aggregate initializer)
18:25: Undefined type
19:14: Only a single value is allowed here (not an aggregate initializer)
20:17: You must init an aggregate with an aggregate initializer !
21:14: Type mismatch/No known conversion
22:26: You must init a map with an aggregate initializer !
23:26: The initializer #2 is not of the type of the map element
23:32: Type mismatch/No known conversion
24:26: The initializer #1 is not of the type of the map key
24:27: You can only assign to a string another string
25:26: The initializer of a map must have an even number of items (alternating keys and values)
30:10: You can't omit the array size unless you are declaring a variable or constant with an aggregate initializer.
32:19: Too many initializers
33:22: You must init an aggregate with an aggregate initializer !
34:23: Only a single value is allowed here (not an aggregate initializer)
36:23: Type mismatch/No known conversion
37:10: Array size must be '*' (for dynamic) or a positive integer value
41:9: Symbol 'uno' is duplicated
45:5: Type mismatch/No known conversion
47:5: Sum operands must be all numbers or all strings.
49:5: Increment and Decrement operations can be applied only to writable integer variables
50:12: Expression must evaluate to a bool
53:13: Expression must evaluate to a bool
56:13: Dead code after terminating statement
59:13: Symbol 'a' is duplicated
61:5: Dead code after terminating statement
61:5: You can only break/continue a for or while loop.
62:5: Dead code after terminating statement
62:5: You can only break/continue a for or while loop.
63:5: You can't return a value from a void function.
68:5: You must return a value from a non-void function.
73:15: Array size must be '*' (for dynamic) or a positive integer value
79:15: Sum operands must be all numbers or all strings.
80:11: Missing index
80:16: Currently ranges are not supported
80:16: Sum operands must be all numbers or all strings.
81:5: Undefined symbol
82:8: Indices must be positive integers
83:8: Index value is out of bound
84:10: Currently ranges are not supported
85:10: Currently ranges are not supported
86:13: Currently ranges are not supported
87:11: Missing index
89:8: You can apply an index list only to objects of type 'array' (did you specify too many indices ?)
90:10: Currently ranges are not supported
91:8: You can apply an index list only to objects of type 'array' (did you specify too many indices ?)
93:7: You can apply an argument list only to an object of type 'function'
94:22: Sum operands must be all numbers or all strings.
95:18: Argument 2: Type mismatch/No known conversion
96:5: Undefined symbol
97:13: Argument 2 is not specified and has no default value
98:13: Can't discard a function value (consider using the syntax _ = fn())
99:14: Argument 1 is an output argument and needs to be a writable variable
100:13: Argument 2 is not specified and has no default value
119:13: Sum operands must be all numbers or all strings.
122:5: Sum operands must be all numbers or all strings.
123:5: Sum operands must be all numbers or all strings.
124:13: Operands must be numbers
125:15: Sum operands must be all numbers or all strings.
129:11: On an integer base you can only use an integer exponent ranging 0 to 63 (but not 0**0)
130:11: On an integer base you can only use an integer exponent ranging 0 to 63 (but not 0**0)
132:12: Operation causes an integer overflow
134:21: Operation causes an overflow
135:27: Operation causes an integer overflow
136:11: Divide by 0
137:11: On an integer base you can only use an integer exponent ranging 0 to 63 (but not 0**0)
138:11: On an integer base you can only use an integer exponent ranging 0 to 63 (but not 0**0)
140:12: Shifting so many bits positions has no purpose on a value of such precision (you get 0 or -1)
141:12: Shifting so many bits positions has no purpose on a value of such precision (you get 0 or -1)
142:13: Operation requires integer operands
143:14: Divide by 0
155:5: Operand types mismatch.
156:22: Value doesn't fit a complex64. use the fake cast notation type([real] + [img]) es: complex128(-1e50 + 5i)
157:5: Operand types mismatch.
158:5: Operand types mismatch.
159:17: Operand types mismatch.
160:5: Operand types mismatch.
161:5: Operand types mismatch.
163:5: Operand types mismatch.
164:5: Operand types mismatch.
165:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
166:5: Operand types mismatch.
167:5: Operand types mismatch.
171:15: Value doesn't fit an int/i32. use the fake cast notation type(literal) es: i64(-0x1_0000_0000)
172:5: Operand types mismatch.
173:5: Operand types mismatch.
174:5: Operand types mismatch.
175:5: Operand types mismatch.
176:5: Operand types mismatch.
177:5: Operand types mismatch.
179:5: Operand types mismatch.
180:19: Operation requires integer operands
181:5: Operand types mismatch.
184:5: Operand types mismatch.
186:5: Operand types mismatch.
187:5: Operand types mismatch.
188:5: Operand types mismatch.
189:5: Operand types mismatch.
190:5: Operand types mismatch.
192:5: Operand types mismatch.
193:5: Operand types mismatch.
195:5: Operand types mismatch.
196:5: Operand types mismatch.
197:5: Operand types mismatch.
198:5: Operand types mismatch.
200:5: Type mismatch in assignment. Please cast explicitly
201:5: Operand types mismatch.
202:5: Operand types mismatch.
203:5: Operand types mismatch.
204:5: Operand types mismatch.
205:5: Operand types mismatch.
206:5: Operand types mismatch.
208:5: Operand types mismatch.
209:5: Type mismatch in assignment. Please cast explicitly
210:5: Operand types mismatch.
211:5: Operand types mismatch.
212:5: Operand types mismatch.
213:5: Operand types mismatch.
214:5: Operand types mismatch.
216:5: Operand types mismatch.
217:5: Operand types mismatch.
218:5: Operand types mismatch.
219:5: Operand types mismatch.
220:5: Operand types mismatch.
221:5: Operand types mismatch.
222:5: Operand types mismatch.
224:5: Operand types mismatch.
225:5: Operand types mismatch.
226:5: Operand types mismatch.
227:5: Operand types mismatch.
228:5: Operand types mismatch.
229:5: Operand types mismatch.
230:5: Operand types mismatch.
232:5: Operand types mismatch.
233:5: Operand types mismatch.
234:5: Operand types mismatch.
235:5: Operand types mismatch.
236:5: Operand types mismatch.
237:5: Operand types mismatch.
238:5: Operand types mismatch.
240:5: Operand types mismatch.
241:5: Operand types mismatch.
242:5: Operand types mismatch.
243:5: Operand types mismatch.
244:5: Operand types mismatch.
245:5: Operand types mismatch.
246:5: Operand types mismatch.
251:19: Operation requires integer operands
252:5: Operand types mismatch.
256:18: Dont' know how to apply an order (i.e. use '>' '<' operators) to complex numbers
263:28: You can only compare two scalar numbers, enums, strings
264:17: You can only compare two scalar numbers, enums, strings
266:5: Arithmetic '&' and '|' operands must be integer numbers.
267:5: Arithmetic '&' and '|' operands must be integer numbers.
268:16: You can apply '&&' and '||' only to bools
271:23: You can apply the & unary operator only to a local variable.
272:24: You can apply the & unary operator only to a local variable.
281:13: Unary '-' only applies to numeric signed basic types
282:13: Unary '-' only applies to numeric signed basic types
283:10: Unary '-' only applies to numeric signed basic types
284:12: Unary '-' only applies to numeric signed basic types
286:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
289:13: The logical not (!) operator requires a boolean
290:13: The logical not (!) operator requires a boolean
291:13: The logical not (!) operator requires a boolean
292:13: The logical not (!) operator requires a boolean
293:13: The logical not (!) operator requires a boolean
294:13: The logical not (!) operator requires a boolean
295:13: The logical not (!) operator requires a boolean
296:10: The logical not (!) operator requires a boolean
298:13: The logical not (!) operator requires a boolean
299:13: The logical not (!) operator requires a boolean
300:13: The logical not (!) operator requires a boolean
302:13: The arithmetic not '~' operator requires an integer value
303:13: The arithmetic not '~' operator requires an integer value
304:13: The arithmetic not '~' operator requires an integer value
309:10: The arithmetic not '~' operator requires an integer value
310:12: The arithmetic not '~' operator requires an integer value
311:13: The arithmetic not '~' operator requires an integer value
316:47: Unallowed conversion.
316:59: Unallowed conversion.
316:88: Please use relational operators to convert numbers and strings to bools.
319:13: Undefined symbol
323:5: Type mismatch/No known conversion
325:12: Can't discard a function value (consider using the syntax _ = fn())
330:13: Undefined symbol
337:14: The iterator name must be a new name
342:10: The iterator name must be a new name
344:19: The variable you are iterating in must be an array
346:19: The variable you are iterating in must be an array
348:19: The variable you are iterating in must be an array
350:19: The variable you are iterating in must be an array
352:19: The variable you are iterating in must be an array
354:5: For loop extrema and step must fit int64
356:5: For loop extrema and step must fit int64
358:5: For loop extrema and step must fit int64
368:5: Step can't be 0
373:5: Writing to a read-only variable
382:5: Type mismatch in assignment. Please cast explicitly
386:5: Type mismatch in assignment. Please cast explicitly
388:5: Type mismatch in assignment. Please cast explicitly
389:5: Type mismatch in assignment. Please cast explicitly
391:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
394:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
396:5: Type mismatch in assignment. Please cast explicitly
397:5: Type mismatch in assignment. Please cast explicitly
398:5: Type mismatch in assignment. Please cast explicitly
399:5: Type mismatch in assignment. Please cast explicitly
400:5: Type mismatch in assignment. Please cast explicitly
401:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
404:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
406:5: Type mismatch in assignment. Please cast explicitly
407:5: Type mismatch in assignment. Please cast explicitly
408:5: Type mismatch in assignment. Please cast explicitly
412:5: Type mismatch in assignment. Please cast explicitly
413:5: Type mismatch in assignment. Please cast explicitly
414:5: Type mismatch in assignment. Please cast explicitly
415:5: Type mismatch in assignment. Please cast explicitly
417:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
420:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
422:5: Type mismatch in assignment. Please cast explicitly
423:5: Type mismatch in assignment. Please cast explicitly
424:5: Type mismatch in assignment. Please cast explicitly
425:5: Type mismatch in assignment. Please cast explicitly
426:5: Type mismatch in assignment. Please cast explicitly
427:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
430:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
432:5: Type mismatch/No known conversion
434:5: You can only assign to a string another string
436:5: You can only assign to a string another string
437:5: You can only assign to a string another string
438:5: You can only assign to a string another string
440:5: You can only assign to a string another string
442:5: You can assign a bool only with a bool (use relational operators to generate bools)
451:5: Type mismatch/No known conversion
454:5: Type mismatch/No known conversion
459:5: Type mismatch/No known conversion
464:5: Type mismatch/No known conversion
467:5: Type mismatch/No known conversion
470:5: Pointer constness mismatch
473:5: Type mismatch/No known conversion
476:5: Type mismatch/No known conversion
478:51: Undefined type
479:5: Type mismatch/No known conversion
482:5: Type mismatch/No known conversion
495:26: Weak pointers are allowed only as non aggregated class members.
496:5: Pointer constness mismatch
509:2: Function must return a value !!
531:2: Function must return a value !!
545:9: Dead code after terminating statement
549:9: Dead code after terminating statement
553:9: Dead code after terminating statement
561:33: Operand types mismatch.
562:25: Operand types mismatch.
564:42: Operation causes an integer overflow
565:42: Operation causes an integer overflow
567:21: Operand types mismatch.
577:35: Operation causes an integer overflow
578:35: Operation causes an integer overflow
579:42: Operand types mismatch.
580:20: Value doesn't fit an int/i32. use the fake cast notation type(literal) es: i64(-0x1_0000_0000)
581:42: Operand types mismatch.
582:20: Value doesn't fit an int/i32. use the fake cast notation type(literal) es: i64(-0x1_0000_0000)
586:25: Shift amount can't be negative
587:19: Shift amount can't be negative
591:42: Value doesn't fit the destination (assignment would cause loss of range or precision).
592:20: Value doesn't fit an int/i32. use the fake cast notation type(literal) es: i64(-0x1_0000_0000)
594:19: The arithmetic not '~' operator requires an integer value
595:19: The arithmetic not '~' operator requires an integer value
598:25: Operand types mismatch.
598:37: Operand types mismatch.
599:23: Operation requires integer operands
600:23: Divide by 0
607:36: Operand types mismatch.
608:21: Operation requires integer operands
611:29: Type mismatch in assignment. Please cast explicitly
612:40: On an integer base you can only use an integer exponent ranging 0 to 63 (but not 0**0)
613:23: On an address the only allowed operator is '*'
614:19: Unary '+' only applies to numeric types
615:21: You can use unary * only on strong pointers
616:14: Argument 1 is an output argument and needs to be a writable variable
618:13: Can't discard a function value (consider using the syntax _ = fn())
619:34: Weak pointers are allowed only as non aggregated class members.
620:14: Argument 1 type mismatch
621:18: Weak pointers are allowed only as non aggregated class members.
622:12: Can't discard a function value (consider using the syntax _ = fn())
624:13: Argument 1 type mismatch
625:12: Too many arguments
626:12: Argument 1 is not specified and has no default value
627:14: You can apply the & unary operator only to a local variable.
628:5: Type mismatch/No known conversion
635:14: On an integer base you can only use an integer exponent ranging 0 to 63 (but not 0**0)
638:27: Weak pointers are allowed only as non aggregated class members.
646:9: Sizeof doesn't apply to this type (it has variable size)
657:14: Array size must be '*' (for dynamic) or a positive integer value
658:5: Symbol 'fvecdimf' is duplicated
658:14: Array size must be '*' (for dynamic) or a positive integer value
662:20: Indices must be positive integers
664:32: Value too big for the type or can't be represented in full precision.
665:15: Result of sign inversion overflows (sing integer literals range -2**63 to 2**64-1). consider using a float literal
666:15: The arithmetic not '~' operator requires an integer value
668:15: Overflow in float to int conversion
669:41: Value too big to be represented in an integer variable.
672:19: Shifting so many bits positions has no purpose on a value of such precision (you get 0 or -1)
675:25: Divide by 0
676:26: Divide by 0
678:16: Overflow in float to int conversion
679:36: Value too big for the type or can't be represented in full precision.
680:29: Shifting so many bits positions has no purpose on a value of such precision (you get 0 or -1)
682:29: Shifting so many bits positions has no purpose on a value of such precision (you get 0 or -1)
689:44: Value too big to be represented in an integer variable.
690:14: The arithmetic not '~' operator requires an integer value
710:5: Increment and Decrement operations can be applied only to writable integer variables
713:14: You can't omit the array size unless you are declaring a variable or constant with an aggregate initializer.
715:20: You can't omit the array size unless you are declaring a variable or constant with an aggregate initializer.
717:18: The argument's initer must be a compile time constant !
717:43: You can only init arguments of type: numeric, enum, string, bool, pointer (the latter only with null)
733:28: A public declaration cannot refer a private symbol
736:2: Function must return a value !!
738:24: You can only return values of type: numeric, enum, string, bool, pointer
740:2: Function must return a value !!
742:12: Public global variables are forbidden !
747:19: Need a const pointer here
759:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
760:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
763:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
764:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
767:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
768:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
770:13: Operation doesn't suppot complex operands
771:13: Operation doesn't suppot complex operands
773:5: You can only swap two writable variables of IDENTICAL type
774:5: You can only swap two writable variables of IDENTICAL type
775:5: You can only swap two writable variables of IDENTICAL type
776:5: You can only swap two writable variables of IDENTICAL type
777:5: You can only swap two writable variables of IDENTICAL type
783:17: Key type must support the == operator (not be a class/interface/map)
790:5: Both called and calling functions must return bool.
796:5: Both called and calling functions must return bool.

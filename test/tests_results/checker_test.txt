
3:11: Auto variables require a single expression initer
8:8: Void only allowed as a function return type
9:8: Undefined type
10:9: Expected a type name
11:13: Void only allowed as a function return type
12:13: Void only allowed as a function return type
13:21: Undefined type
14:10: Undefined type
15:15: Void only allowed as a function return type
16:28: You can apply argument initers only to input parameters
17:14: Only a single value is allowed here(not an aggregate initializer)
18:25: Undefined type
19:14: Only a single value is allowed here (not an aggregate initializer)
20:17: You must init an aggregate with an aggregate initializer !
21:14: Type mismatch/No known conversion
22:26: You must init a map with an aggregate initializer !
23:26: The initializer #2 is not of the type of the map element
23:32: Type mismatch/No known conversion
24:26: The initializer #1 is not of the type of the map key
24:27: You can only assign to a string another string
25:26: The initializer of a map must have an even number of items (alternating keys and values)
30:10: You can't omit the array size unless you are declaring a variable or constant with an aggregate initializer.
32:19: Too many initializers
33:22: You must init an aggregate with an aggregate initializer !
34:23: Only a single value is allowed here (not an aggregate initializer)
36:23: Type mismatch/No known conversion
37:10: Array size must be '*' (for dynamic) or a positive integer value
41:9: Symbol 'uno' is duplicated
45:5: Type mismatch/No known conversion
47:5: Sum operands must be all numbers or all strings.
49:5: Increment and Decrement operations can be applied only to writable integer variables
50:12: Expression must evaluate to a bool
53:13: Expression must evaluate to a bool
56:13: Dead code after terminating statement
59:13: Symbol 'a' is duplicated
61:5: Dead code after terminating statement
61:5: You can only break/continue a for or while loop.
62:5: Dead code after terminating statement
62:5: You can only break/continue a for or while loop.
63:5: You can't return a value from a void function.
68:5: You must return a value from a non-void function.
73:15: Array size must be '*' (for dynamic) or a positive integer value
79:15: Sum operands must be all numbers or all strings.
80:11: Missing index
80:16: Currently ranges are not supported
80:16: Sum operands must be all numbers or all strings.
81:5: Undefined symbol
82:8: Indices must be positive integers
83:8: Index value is out of bound
84:10: Currently ranges are not supported
85:10: Currently ranges are not supported
86:13: Currently ranges are not supported
87:11: Missing index
89:8: You can apply an index list only to objects of type 'array' (did you specify too many indices ?)
90:10: Currently ranges are not supported
91:8: You can apply an index list only to objects of type 'array' (did you specify too many indices ?)
93:7: You can apply an argument list only to an object of type 'function'
94:22: Sum operands must be all numbers or all strings.
95:18: Argument 2: Type mismatch/No known conversion
96:5: Undefined symbol
97:13: Argument 2 is not specified and has no default value
98:13: Can't discard a function value (consider using the syntax _ = fn())
99:14: Argument 1 is an output argument and needs to be a writable variable
100:13: Argument 2 is not specified and has no default value
119:13: Sum operands must be all numbers or all strings.
122:5: Sum operands must be all numbers or all strings.
123:5: Sum operands must be all numbers or all strings.
124:13: Operands must be numbers
125:15: Sum operands must be all numbers or all strings.
129:11: On an integer base you can only use an integer exponent ranging 0 to 63 (but not 0**0)
130:11: On an integer base you can only use an integer exponent ranging 0 to 63 (but not 0**0)
132:12: Operation causes an integer overflow
134:21: Operation causes an overflow
135:27: Operation causes an integer overflow
136:11: Divide by 0
137:11: On an integer base you can only use an integer exponent ranging 0 to 63 (but not 0**0)
138:11: On an integer base you can only use an integer exponent ranging 0 to 63 (but not 0**0)
140:12: Shifting so many bits positions has no purpose on a value of such precision (you get 0 or -1)
141:12: Shifting so many bits positions has no purpose on a value of such precision (you get 0 or -1)
142:13: Operation requires integer operands
143:14: Divide by 0
155:5: Operand types mismatch.
156:22: Value doesn't fit a complex64. use the fake cast notation type([real] + [img]) es: complex128(-1e50 + 5i)
157:5: Operand types mismatch.
158:5: Operand types mismatch.
159:17: Operand types mismatch.
160:5: Operand types mismatch.
161:5: Operand types mismatch.
163:5: Operand types mismatch.
164:5: Operand types mismatch.
165:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
166:5: Operand types mismatch.
167:5: Operand types mismatch.
171:15: Value doesn't fit an int/i32. use the fake cast notation type(literal) es: i64(-0x1_0000_0000)
172:5: Operand types mismatch.
173:5: Operand types mismatch.
174:5: Operand types mismatch.
175:5: Operand types mismatch.
176:5: Operand types mismatch.
177:5: Operand types mismatch.
179:5: Operand types mismatch.
180:19: Operation requires integer operands
181:5: Operand types mismatch.
184:5: Operand types mismatch.
186:5: Operand types mismatch.
187:5: Operand types mismatch.
188:5: Operand types mismatch.
189:5: Operand types mismatch.
190:5: Operand types mismatch.
192:5: Operand types mismatch.
193:5: Operand types mismatch.
195:5: Operand types mismatch.
196:5: Operand types mismatch.
197:5: Operand types mismatch.
198:5: Operand types mismatch.
200:5: Type mismatch in assignment. Please cast explicitly
201:5: Operand types mismatch.
202:5: Operand types mismatch.
203:5: Operand types mismatch.
204:5: Operand types mismatch.
205:5: Operand types mismatch.
206:5: Operand types mismatch.
208:5: Operand types mismatch.
209:5: Type mismatch in assignment. Please cast explicitly
210:5: Operand types mismatch.
211:5: Operand types mismatch.
212:5: Operand types mismatch.
213:5: Operand types mismatch.
214:5: Operand types mismatch.
216:5: Operand types mismatch.
217:5: Operand types mismatch.
218:5: Operand types mismatch.
219:5: Operand types mismatch.
220:5: Operand types mismatch.
221:5: Operand types mismatch.
222:5: Operand types mismatch.
224:5: Operand types mismatch.
225:5: Operand types mismatch.
226:5: Operand types mismatch.
227:5: Operand types mismatch.
228:5: Operand types mismatch.
229:5: Operand types mismatch.
230:5: Operand types mismatch.
232:5: Operand types mismatch.
233:5: Operand types mismatch.
234:5: Operand types mismatch.
235:5: Operand types mismatch.
236:5: Operand types mismatch.
237:5: Operand types mismatch.
238:5: Operand types mismatch.
240:5: Operand types mismatch.
241:5: Operand types mismatch.
242:5: Operand types mismatch.
243:5: Operand types mismatch.
244:5: Operand types mismatch.
245:5: Operand types mismatch.
246:5: Operand types mismatch.
251:19: Operation requires integer operands
252:5: Operand types mismatch.
256:18: Dont' know how to apply an order (i.e. use '>' '<' operators) to complex numbers
263:28: You can only compare two scalar numbers, enums, strings
264:17: You can only compare two scalar numbers, enums, strings
266:5: Arithmetic '&' and '|' operands must be integer numbers.
267:5: Arithmetic '&' and '|' operands must be integer numbers.
268:16: You can apply '&&' and '||' only to bools
271:23: You can apply the & unary operator only to a local variable.
272:24: You can apply the & unary operator only to a local variable.
281:13: Unary '-' only applies to numeric signed basic types
282:13: Unary '-' only applies to numeric signed basic types
283:10: Unary '-' only applies to numeric signed basic types
284:12: Unary '-' only applies to numeric signed basic types
286:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
289:13: The logical not (!) operator requires a boolean
290:13: The logical not (!) operator requires a boolean
291:13: The logical not (!) operator requires a boolean
292:13: The logical not (!) operator requires a boolean
293:13: The logical not (!) operator requires a boolean
294:13: The logical not (!) operator requires a boolean
295:13: The logical not (!) operator requires a boolean
296:10: The logical not (!) operator requires a boolean
298:13: The logical not (!) operator requires a boolean
299:13: The logical not (!) operator requires a boolean
300:13: The logical not (!) operator requires a boolean
302:13: The arithmetic not '~' operator requires an integer value
303:13: The arithmetic not '~' operator requires an integer value
304:13: The arithmetic not '~' operator requires an integer value
309:10: The arithmetic not '~' operator requires an integer value
310:12: The arithmetic not '~' operator requires an integer value
311:13: The arithmetic not '~' operator requires an integer value
316:47: Unallowed conversion.
316:59: Unallowed conversion.
316:88: Please use relational operators to convert numbers and strings to bools.
319:13: Undefined symbol
323:5: Type mismatch/No known conversion
325:12: Can't discard a function value (consider using the syntax _ = fn())
328:9: Writing to a read-only variable
329:18: Undefined type
332:13: Undefined symbol
334:9: Writing to a read-only variable
335:18: Undefined type
339:14: The index name must be either a new name or the name of a reusable index
341:22: The iterator name must be a new name
346:10: The index name must be either a new name or the name of a reusable index
346:14: The iterator name must be a new name
348:19: The variable you are iterating in must be an array
350:19: The variable you are iterating in must be an array
352:19: The variable you are iterating in must be an array
354:19: The variable you are iterating in must be an array
356:19: The variable you are iterating in must be an array
358:5: For loop extrema and step must fit int64
360:5: For loop extrema and step must fit int64
362:5: For loop extrema and step must fit int64
372:5: Step can't be 0
377:5: Writing to a read-only variable
386:5: Type mismatch in assignment. Please cast explicitly
390:5: Type mismatch in assignment. Please cast explicitly
392:5: Type mismatch in assignment. Please cast explicitly
393:5: Type mismatch in assignment. Please cast explicitly
395:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
398:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
400:5: Type mismatch in assignment. Please cast explicitly
401:5: Type mismatch in assignment. Please cast explicitly
402:5: Type mismatch in assignment. Please cast explicitly
403:5: Type mismatch in assignment. Please cast explicitly
404:5: Type mismatch in assignment. Please cast explicitly
405:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
408:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
410:5: Type mismatch in assignment. Please cast explicitly
411:5: Type mismatch in assignment. Please cast explicitly
412:5: Type mismatch in assignment. Please cast explicitly
416:5: Type mismatch in assignment. Please cast explicitly
417:5: Type mismatch in assignment. Please cast explicitly
418:5: Type mismatch in assignment. Please cast explicitly
419:5: Type mismatch in assignment. Please cast explicitly
421:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
424:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
426:5: Type mismatch in assignment. Please cast explicitly
427:5: Type mismatch in assignment. Please cast explicitly
428:5: Type mismatch in assignment. Please cast explicitly
429:5: Type mismatch in assignment. Please cast explicitly
430:5: Type mismatch in assignment. Please cast explicitly
431:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
434:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
436:5: Type mismatch/No known conversion
438:5: You can only assign to a string another string
440:5: You can only assign to a string another string
441:5: You can only assign to a string another string
442:5: You can only assign to a string another string
444:5: You can only assign to a string another string
446:5: You can assign a bool only with a bool (use relational operators to generate bools)
455:5: Type mismatch/No known conversion
458:5: Type mismatch/No known conversion
463:5: Type mismatch/No known conversion
468:5: Type mismatch/No known conversion
471:5: Type mismatch/No known conversion
474:5: Pointer constness mismatch
477:5: Type mismatch/No known conversion
480:5: Type mismatch/No known conversion
482:51: Undefined type
483:5: Type mismatch/No known conversion
486:5: Type mismatch/No known conversion
499:26: Weak pointers are allowed only as non aggregated class members.
500:5: Pointer constness mismatch
513:2: Function must return a value !!
535:2: Function must return a value !!
549:9: Dead code after terminating statement
553:9: Dead code after terminating statement
557:9: Dead code after terminating statement
565:33: Operand types mismatch.
566:25: Operand types mismatch.
568:42: Operation causes an integer overflow
569:42: Operation causes an integer overflow
571:21: Operand types mismatch.
581:35: Operation causes an integer overflow
582:35: Operation causes an integer overflow
583:42: Operand types mismatch.
584:20: Value doesn't fit an int/i32. use the fake cast notation type(literal) es: i64(-0x1_0000_0000)
585:42: Operand types mismatch.
586:20: Value doesn't fit an int/i32. use the fake cast notation type(literal) es: i64(-0x1_0000_0000)
590:25: Shift amount can't be negative
591:19: Shift amount can't be negative
595:42: Value doesn't fit the destination (assignment would cause loss of range or precision).
596:20: Value doesn't fit an int/i32. use the fake cast notation type(literal) es: i64(-0x1_0000_0000)
598:19: The arithmetic not '~' operator requires an integer value
599:19: The arithmetic not '~' operator requires an integer value
602:25: Operand types mismatch.
602:37: Operand types mismatch.
603:23: Operation requires integer operands
604:23: Divide by 0
611:36: Operand types mismatch.
612:21: Operation requires integer operands
615:29: Type mismatch in assignment. Please cast explicitly
616:40: On an integer base you can only use an integer exponent ranging 0 to 63 (but not 0**0)
617:23: On an address the only allowed operator is '*'
618:19: Unary '+' only applies to numeric types
619:21: You can use unary * only on strong pointers
620:14: Argument 1 is an output argument and needs to be a writable variable
622:13: Can't discard a function value (consider using the syntax _ = fn())
623:34: Weak pointers are allowed only as non aggregated class members.
624:14: Argument 1 type mismatch
625:18: Weak pointers are allowed only as non aggregated class members.
626:12: Can't discard a function value (consider using the syntax _ = fn())
628:13: Argument 1 type mismatch
629:12: Too many arguments
630:12: Argument 1 is not specified and has no default value
631:14: You can apply the & unary operator only to a local variable.
632:5: Type mismatch/No known conversion
639:14: On an integer base you can only use an integer exponent ranging 0 to 63 (but not 0**0)
642:27: Weak pointers are allowed only as non aggregated class members.
650:9: Sizeof doesn't apply to this type (it has variable size)
661:14: Array size must be '*' (for dynamic) or a positive integer value
662:5: Symbol 'fvecdimf' is duplicated
662:14: Array size must be '*' (for dynamic) or a positive integer value
666:20: Indices must be positive integers
668:32: Value too big for the type or can't be represented in full precision.
669:15: Result of sign inversion overflows (sing integer literals range -2**63 to 2**64-1). consider using a float literal
670:15: The arithmetic not '~' operator requires an integer value
672:15: Overflow in float to int conversion
673:41: Value too big to be represented in an integer variable.
676:19: Shifting so many bits positions has no purpose on a value of such precision (you get 0 or -1)
679:25: Divide by 0
680:26: Divide by 0
682:16: Overflow in float to int conversion
683:36: Value too big for the type or can't be represented in full precision.
684:29: Shifting so many bits positions has no purpose on a value of such precision (you get 0 or -1)
686:29: Shifting so many bits positions has no purpose on a value of such precision (you get 0 or -1)
693:44: Value too big to be represented in an integer variable.
694:14: The arithmetic not '~' operator requires an integer value
714:5: Increment and Decrement operations can be applied only to writable integer variables
717:14: You can't omit the array size unless you are declaring a variable or constant with an aggregate initializer.
719:20: You can't omit the array size unless you are declaring a variable or constant with an aggregate initializer.
721:18: The argument's initer must be a compile time constant !
721:43: You can only init arguments of type: numeric, enum, string, bool, pointer (the latter only with null)
737:28: A public declaration cannot refer a private symbol
740:2: Function must return a value !!
742:24: You can only return values of type: numeric, enum, string, bool, pointer
744:2: Function must return a value !!
746:12: Public global variables are forbidden !
751:19: Need a const pointer here
763:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
764:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
767:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
768:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
771:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
772:5: Value doesn't fit the destination (assignment would cause loss of range or precision).
774:13: Operation doesn't suppot complex operands
775:13: Operation doesn't suppot complex operands
777:5: You can only swap two writable variables of IDENTICAL type
778:5: You can only swap two writable variables of IDENTICAL type
779:5: You can only swap two writable variables of IDENTICAL type
780:5: You can only swap two writable variables of IDENTICAL type
781:5: You can only swap two writable variables of IDENTICAL type
787:17: Key type must support the == operator (not be a class/interface/map)
